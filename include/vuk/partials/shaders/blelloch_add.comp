#version 450
#pragma shader_stage(compute)

layout (std430, binding = 1) buffer BufferOut {
	uint[] g_odata;
};

layout (std430, binding = 2) buffer readonly Temp {
    uint out_wg_count;
    uint out_unused[2];
    uint out_count;
	uint[] g_temp;
};

layout (std430, binding = 4) buffer readonly BufferCount {
    readonly uint wg_count;
    uint unused[2];
    readonly uint count;
};

#define SIZE 256
layout (local_size_x = SIZE) in;

// https://developer.nvidia.com/gpugems/gpugems3/part-vi-gpu-computing/chapter-39-parallel-prefix-sum-scan-cuda
const uint array_size = 2*SIZE;

layout(constant_id = 0) const uint temp_offset = array_size;

uint linear_index(uvec3 id){
	uvec3 mp = gl_NumWorkGroups * gl_WorkGroupSize;
	return id.z * mp.y * mp.x + id.y * mp.x + id.x * 1;
}

void main() {
    if(gl_WorkGroupID.x >= wg_count - 1) return; // last WG unused
	uint gid = linear_index(gl_GlobalInvocationID);
    uint a1 = g_odata[2*gid + array_size]; // we don't process the first block
    uint a2 = g_odata[2*gid+1 + array_size];

    g_odata[2*gid + array_size] = a1 + g_temp[gl_WorkGroupID.x + temp_offset + 1]; // write results to device memory      
    g_odata[2*gid+1 + array_size] = a2 + g_temp[gl_WorkGroupID.x + temp_offset + 1];
}